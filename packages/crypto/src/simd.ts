export class SIMD {
  private static wasmSIMD: WebAssembly.Instance | null = null;

  /**
   * Initializes the SIMD module.
   * Throws immediately if SIMD is not supported.
   */
  static async initialize(): Promise<void> {
    const simdSupported = await (await import('wasm-feature-detect')).simd();
    if (!simdSupported) {
      throw new Error('SIMD is not supported in this environment.');
    }

    // Load the wasm module using the improved loader.
    this.wasmSIMD = await (await import('./wasm-loader')).loadWasmModule('simd_sha3.wasm');
  }

  /**
   * Computes the batch SHA3-256 hash for a set of inputs generated by appending nonce values 
   * to the headerBase. The inputs are computed for nonces in the range [startNonce, startNonce + batchSize).
   *
   * @param headerBase - Base header string.
   * @param startNonce - Starting nonce value.
   * @param batchSize - Number of entries in the batch.
   * @returns Array of hash strings.
   */
  static async batchHashSHA3(headerBase: string, startNonce: number, batchSize: number): Promise<string[]> {
    if (!this.wasmSIMD) {
      throw new Error('SIMD not supported or not initialized');
    }

    // New check: Ensure 'batch_hash_sha3_256' export exists.
    const batchHashFunction = this.wasmSIMD.exports.batch_hash_sha3_256;
    if (typeof batchHashFunction !== 'function') {
      throw new Error('WASM module does not export batch_hash_sha3_256 function');
    }

    // Construct batch input array.
    const inputs = Array.from({ length: batchSize }, (_, i) => `${headerBase}${startNonce + i}`);
    const jsonData = JSON.stringify(inputs);
    const input = new TextEncoder().encode(jsonData);

    // Check for required exports for manual memory management.
    if ('memory' in this.wasmSIMD.exports &&
        typeof this.wasmSIMD.exports.allocate === 'function' &&
        typeof this.wasmSIMD.exports.deallocate === 'function') {
      const memory = this.wasmSIMD.exports.memory as WebAssembly.Memory;
      const allocate = this.wasmSIMD.exports.allocate as (size: number) => number;
      const deallocate = this.wasmSIMD.exports.deallocate as (ptr: number, size: number) => void;
      
      const inputPtr = allocate(input.length);
      if (!inputPtr) { // New check for allocation pointer validity.
        throw new Error('WASM allocate returned an invalid pointer.');
      }
      
      try {
        const memoryBuffer = new Uint8Array(memory.buffer);
        memoryBuffer.set(input, inputPtr);

        // Call the WASM function passing pointer and length.
        const outputPtr = (batchHashFunction as (ptr: number, len: number) => number)(inputPtr, input.length);
        if (!outputPtr) { // New check: Verify valid non-null output pointer.
          throw new Error('WASM function returned an invalid output pointer.');
        }
        
        let result: string[];
        try {
          const outputJSON = SIMD.decodeWasmString(outputPtr, memory);
          try {
            result = JSON.parse(outputJSON);
          } catch (parseError) {
            throw new Error(`Failed to parse output JSON from WASM: ${parseError}`);
          }
        } finally {
          // Calculate the length of the output string (including the null terminator)
          const memoryBuffer = new Uint8Array(memory.buffer);
          let end = outputPtr;
          const max = memoryBuffer.length;
          while (end < max && memoryBuffer[end] !== 0) {
            end++;
          }
          const outputSize = end - outputPtr + 1;
          deallocate(outputPtr, outputSize);
        }
        return result;
      } finally {
        deallocate(inputPtr, input.length);
      }
    } else {
      // Fallback: if manual memory management is not provided
      return (batchHashFunction as (input: Uint8Array) => string[])(input);
    }
  }

  /**
   * Helper to decode a null-terminated string from WASM memory.
   * Throws an error if no null terminator is found within memory bounds.
   *
   * @param ptr Pointer to the string in WASM memory.
   * @param memory The wasm.Memory instance.
   * @returns The decoded JavaScript string.
   */
  private static decodeWasmString(ptr: number, memory: WebAssembly.Memory): string {
    const memoryBuffer = new Uint8Array(memory.buffer);
    let end = ptr;
    const max = memoryBuffer.length;
    while (end < max && memoryBuffer[end] !== 0) {
      end++;
    }
    if (end === max) {
      throw new Error('Failed to decode string from WASM memory: null terminator not found');
    }
    const stringBytes = memoryBuffer.subarray(ptr, end);
    return new TextDecoder('utf8').decode(stringBytes);
  }
}
